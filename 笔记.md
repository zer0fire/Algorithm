Outliers
一万小时定律
Chunk it up 切碎知识-连接知识
Deliberate Practicing 刻意练习
    单独拿出来
    练习一些枯燥、不舒服的地方
Feedback 反馈
    即时反馈
    主动反馈-去找东西
    被动反馈-cr、有人指点

切题四件套
    Clarification
        询问题目细节、边界条件、可能的极端错误情况
    Possible-Solution
        所有可能的解法都和面试官沟通一遍
        - compare 时间空间复杂度
        - optimal 最优解
    Coding
    写代码
    Test-cases
    测试用例

Stack vector
Queue linkedLIst
Set
Map
HashTable 


不要为了切题而切题，去练习不熟的算法
满足感下降的时候，去开拓新题
做过的题也复习
面试的沟通交流很重要（TeamWork，要让面试官和你配合解答问题）

```js
function qs(ary, start = 0, end = ary.length - 1) {
    if (start >= end) {
        return ary
    }
    const pivotIdx = ((Math.random() * (end - start)) + start) | 0

    return ary
}

function qsShort(ary) {
    if (!ary.length) {
        return ary
    }
    let midIdx = ary.length / 2 | 0
    let mid = ary[midIdx]
    let [left, right] = [ary.filter((it, idx) => it <= mid && idx !== midIdx), ary.filter(it => it > mid)]
    return [...qsShort(left), mid, ...qsShort(right)]
}
function fib(n) {
    const ary = []
    ary[0] = 1
    ary[1] = 1
    for(let i = 3; i < n; i++) {
        ary[i] = ary[i-1] + ary[i-2]
    }
    return ary[n]
}
function fib2(n) {
    const M = [
        [1, 1]
        [1, 0]
    ]
    return M ** n - 1 * [[1],[1]]
}
```
分治法 N 
通项公式（logN）
矩阵相乘（logN）


Triangle
1. Clarification 数组多大，是否有负数
2. Possible-Solution
    - brute-force
    - DP

terminator
           
process

drill down

clear states 


PriorityQueue 重要程度 / 完成时间，值越大越重要（impact 和 important）
凯立公式
博弈论


Disjoint Set 并查集
Trie 字母树
BloomFilter 布隆过滤器
LRU Cache

O(1)
O(logN)
O(N)
O(N^2)
O(N^3)
O(2^N)
O(n!)


Master Theorem 主定理
O(logN) 二分法
O(N) 二叉树遍历
O(N) 排序 Optimal Sorted matrix Search 矩阵查找
O(N*logN) Merge Sort 归并排序等